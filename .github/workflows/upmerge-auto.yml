name: Auto Upmerge

on:
  workflow_run:
    workflows: ["Upmerge Test"]
    types: [completed]

jobs:
  auto-upmerge:
    runs-on: ubuntu-latest
    # Only run if the upmerge test completed successfully
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    steps:
      - name: "Debug Vars"
        env:
          WORKFLOW_RUN_ID: ${{ github.event.workflow_run.id }}
          WORKFLOW_RUN_HEAD_SHA: ${{ github.event.workflow_run.head_sha }}
          WORKFLOW_RUN_HEAD_BRANCH: ${{ github.event.workflow_run.head_branch }}
          WORKFLOW_RUN_PR_NUMBER: ${{ github.event.workflow_run.pull_requests[0].number }}
        run: |
          echo "Workflow Run ID: $WORKFLOW_RUN_ID"
          echo "Workflow Run Head SHA: $WORKFLOW_RUN_HEAD_SHA"
          echo "Workflow Run Head Branch: $WORKFLOW_RUN_HEAD_BRANCH"
          echo "Workflow Run PR Number: $WORKFLOW_RUN_PR_NUMBER"

      - name: "Download Upmerge Test Results"
        uses: actions/download-artifact@v4
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          run-id: ${{ github.event.workflow_run.id }}
          pattern: "upmerge-test-results-pr-*"
          merge-multiple: true
          path: artifacts/

      - name: "Setup Python"
        uses: actions/setup-python@v5
        with:
          python-version: "3.8"

      - name: "Install dependencies"
        run: |
          set -xe
          python -VV
          python -m site
          python -m pip install --upgrade pip setuptools wheel

      - name: "Checkout"
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0
          fetch-tags: true

      - name: "Configure Git"
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: "Perform Auto Upmerge"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          WORKFLOW_RUN_ID: ${{ github.event.workflow_run.id }}
          WORKFLOW_RUN_HEAD_SHA: ${{ github.event.workflow_run.head_sha }}
          WORKFLOW_RUN_HEAD_BRANCH: ${{ github.event.workflow_run.head_branch }}
          WORKFLOW_RUN_PR_NUMBER: ${{ github.event.workflow_run.pull_requests[0].number }}
        shell: python
        run: |
          import os
          import re
          import subprocess
          import time
          import sys
          import json
          from pathlib import Path

          def extractVersion(versionStr):
              parts = versionStr.split('.')
              if len(parts) != 3:
                  print('Invalid version: ' + versionStr)
                  sys.exit(1)
              if parts[2].lower() == 'x':
                  parts[2] = '0'

              major, minor, point = map(int, parts)
              return [major, minor, point]

          def getTagVersionForCmd(cmd):
              versionPattern = re.compile(r".*([0-9]+\.[0-9]+\.[0-9]+).*")

              # Get latest release version
              gitTagProcess = subprocess.Popen(cmd, stdout=subprocess.PIPE, shell=True)
              (output, err) = gitTagProcess.communicate()
              gitTagProcessStatus = gitTagProcess.wait()

              if gitTagProcessStatus != 0:
                  print('Unable to retrieve latest git tag.')
                  sys.exit(1)

              latestGitTag = str(output)

              versionMatch = versionPattern.match(latestGitTag)
              if versionMatch:
                  return extractVersion(versionMatch.group(1))
              else:
                  print('Unable to extract version from git tag.')
                  sys.exit(2)

          def buildBranchString(version):
              major, minor, point = map(int, version)
              return f"candidate-{major}.{minor}.x"

          def createReleaseTagPattern(projectConfig, major = None, minor = None, point = None):
              releaseTagPrefix = projectConfig.get('tagPrefix')
              releaseTagPostfix = projectConfig.get('tagPostfix')

              if releaseTagPrefix is None or releaseTagPostfix is None:
                  print('Error: PROJECT_CONFIG is missing required fields: tagPrefix and/or tagPostfix')
                  sys.exit(1)

              releaseTagPattern = releaseTagPrefix
              if major is not None:
                  releaseTagPattern += str(major) + '\\.'
              else:
                  releaseTagPattern += '[0-9]+\\.'

              if minor is not None:
                  releaseTagPattern += str(minor) + '\\.'
              else:
                  releaseTagPattern += '[0-9]+\\.'

              if point is not None:
                  releaseTagPattern += str(point) + '(-[0-9]+)?'
              else:
                  releaseTagPattern += '[0-9]+(-[0-9]+)?'

              releaseTagPattern += releaseTagPostfix + '$'

              return releaseTagPattern

          def getLatestSemVer(projectConfig, major = None, minor = None, point = None):
              cmd = "git tag --list --sort=-v:refname | grep -E '" + createReleaseTagPattern(projectConfig, major, minor, point) + "' | head -n 1"
              return getTagVersionForCmd(cmd)

          def generateUpMergeBranchList(projectConfig, branchName):
              latestVersion = getLatestSemVer(projectConfig)

              versions = []
              if branchName == "master":
                  return versions
              else:
                  # Extract candidate branch major / minor version
                  candidateBranchPattern = re.compile(r"candidate-([0-9]+\.[0-9]+\.([0-9]+|x)).*")
                  branchVersionMatch = candidateBranchPattern.match(branchName)
                  branchVersion = extractVersion(branchVersionMatch.group(1))

                  # Get latest release in branch
                  latestBranchVer = getLatestSemVer(projectConfig, branchVersion[0], branchVersion[1])

                  curMajor = branchVersion[0]
                  latestMajor = latestVersion[0]
                  while curMajor <= latestMajor:
                      latestVersionInMajor = getLatestSemVer(projectConfig, curMajor)

                      curMinor = 0
                      if curMajor == branchVersion[0]:
                          curMinor = branchVersion[1]

                      latestMinor = latestVersionInMajor[1]

                      while curMinor <= latestMinor:
                          latestPointInMinor = getLatestSemVer(projectConfig, curMajor, curMinor)
                          versions.append(buildBranchString([latestPointInMinor[0], latestPointInMinor[1], latestPointInMinor[2] + 2]))
                          curMinor += 2
                      curMajor += 1

              return versions

          def getTargetInBranchVersion(targetBranch):
              # Use git show to get the version from the top-level pom.xml
              cmd = ["git", "show", f"origin/{targetBranch}:pom.xml"]
              result = subprocess.run(cmd, capture_output=True, text=True, check=True)
              pom_content = result.stdout

              version_pattern = re.compile(r'<version>(\s*[0-9]+\.[0-9]+\.[0-9]+(-[0-9]+)?(-SNAPSHOT)?\s*)</version>')
              match = version_pattern.search(pom_content)
              if match:
                  return match.group(1).strip()
              else:
                  print(f"Error: Unable to find version in pom.xml for branch {targetBranch}")
                  sys.exit(1)

          def loadTestResults():
              artifacts_path = Path('artifacts')
              
              if not artifacts_path.exists():
                  print('Artifacts directory not found - cannot determine successful merge targets')
                  return None
              
              files = list(artifacts_path.iterdir())
              print(f'Available files: {[f.name for f in files]}')
              
              results_file = None
              for file in files:
                  if file.name.endswith('upmerge-test-results.json'):
                      results_file = file
                      break
              
              if not results_file:
                  print('No upmerge test results found')
                  return None
                  
              try:
                  with open(results_file, 'r') as f:
                      data = json.load(f)
                  return data
              except Exception as e:
                  print(f'Error loading results file: {e}')
                  return None

          def performUpmerge(sourceBranch, targetBranch, targetVersion, pr_info):
              print(f"\n=== Performing upmerge from {sourceBranch} to {targetBranch} ===")
              
              try:
                  # Checkout target branch
                  print(f"Checking out target branch: {targetBranch}")
                  checkout_result = subprocess.run(
                      ["git", "checkout", f"origin/{targetBranch}"],
                      capture_output=True, text=True
                  )
                  if checkout_result.returncode != 0:
                      print(f"Failed to checkout {targetBranch}: {checkout_result.stderr}")
                      return False
                  
                  # Create a new local branch for the upmerge
                  upmerge_branch = f"upmerge-{sourceBranch}-to-{targetBranch}-{int(time.time())}"
                  print(f"Creating upmerge branch: {upmerge_branch}")
                  create_branch_result = subprocess.run(
                      ["git", "checkout", "-b", upmerge_branch],
                      capture_output=True, text=True
                  )
                  if create_branch_result.returncode != 0:
                      print(f"Failed to create branch {upmerge_branch}: {create_branch_result.stderr}")
                      return False
                  
                  # Merge from source branch head
                  source_sha = os.environ.get('WORKFLOW_RUN_HEAD_SHA')
                  print(f"Merging changes from {source_sha}")
                  merge_result = subprocess.run(
                      ["git", "merge", source_sha, "--no-edit", "-m", f"Auto upmerge from {sourceBranch} to {targetBranch} (PR #{pr_info['number']})"],
                      capture_output=True, text=True
                  )
                  if merge_result.returncode != 0:
                      print(f"Merge failed: {merge_result.stderr}")
                      return False
                  
                  # Update version in pom.xml files
                  print(f"Updating version to {targetVersion}")
                  mvn_result = subprocess.run(
                      ["mvn", "versions:set", f"-DnewVersion={targetVersion}", "-DgenerateBackupPoms=false"],
                      capture_output=True, text=True
                  )
                  if mvn_result.returncode != 0:
                      print(f"Maven version update failed: {mvn_result.stderr}")
                      return False
                  
                  # Add and commit version changes
                  add_result = subprocess.run(["git", "add", "-A"], capture_output=True, text=True)
                  if add_result.returncode != 0:
                      print(f"Git add failed: {add_result.stderr}")
                      return False
                  
                  # Check if there are changes to commit
                  status_result = subprocess.run(["git", "status", "--porcelain"], capture_output=True, text=True)
                  if status_result.stdout.strip():
                      commit_result = subprocess.run(
                          ["git", "commit", "-m", f"Update version to {targetVersion} for {targetBranch}"],
                          capture_output=True, text=True
                      )
                      if commit_result.returncode != 0:
                          print(f"Git commit failed: {commit_result.stderr}")
                          return False
                  
                  # Push the upmerge branch
                  print(f"Pushing upmerge branch: {upmerge_branch}")
                  push_result = subprocess.run(
                      ["git", "push", "origin", upmerge_branch],
                      capture_output=True, text=True
                  )
                  if push_result.returncode != 0:
                      print(f"Push failed: {push_result.stderr}")
                      return False
                  
                  # Create a pull request for the upmerge
                  print(f"Creating PR for upmerge to {targetBranch}")
                  pr_title = f"Auto upmerge from {sourceBranch} to {targetBranch} (Original PR #{pr_info['number']})"
                  pr_body = f"""This is an automatic upmerge from {sourceBranch} to {targetBranch}.

Original PR: #{pr_info['number']} - {pr_info['title']}
Original Author: @{pr_info['author']}

Changes:
- Merged changes from {sourceBranch} 
- Updated version to {targetVersion}

This PR was automatically created by the auto-upmerge workflow."""
                  
                  # Use GitHub API to create the PR
                  import json as json_mod
                  pr_data = {
                      "title": pr_title,
                      "body": pr_body,
                      "head": upmerge_branch,
                      "base": targetBranch
                  }
                  
                  pr_create_result = subprocess.run([
                      "curl", "-X", "POST",
                      f"https://api.github.com/repos/{os.environ['GITHUB_REPOSITORY']}/pulls",
                      "-H", "Accept: application/vnd.github.v3+json",
                      "-H", f"Authorization: token {os.environ['GITHUB_TOKEN']}",
                      "-H", "Content-Type: application/json",
                      "--data", json_mod.dumps(pr_data)
                  ], capture_output=True, text=True)
                  
                  if pr_create_result.returncode != 0:
                      print(f"PR creation failed: {pr_create_result.stderr}")
                      return False
                  
                  try:
                      pr_response = json_mod.loads(pr_create_result.stdout)
                      if 'html_url' in pr_response:
                          print(f"Successfully created upmerge PR: {pr_response['html_url']}")
                          return True
                      else:
                          print(f"PR creation response: {pr_create_result.stdout}")
                          return False
                  except json_mod.JSONDecodeError:
                      print(f"Invalid JSON response: {pr_create_result.stdout}")
                      return False
                  
              except Exception as e:
                  print(f"Error during upmerge to {targetBranch}: {e}")
                  return False

          # Main execution
          workflow_run_pr_number = os.environ.get('WORKFLOW_RUN_PR_NUMBER')
          
          if not workflow_run_pr_number:
              print("No PR number found in workflow run")
              sys.exit(1)
          
          # Load test results to determine which branches were successful
          test_results = loadTestResults()
          if not test_results:
              print("Could not load test results - aborting auto upmerge")
              sys.exit(1)
          
          successful_merges = test_results.get('successful_merges', [])
          base_branch = test_results.get('base_branch', 'unknown')
          
          if not successful_merges:
              print("No successful merges found in test results - nothing to upmerge")
              sys.exit(0)
          
          pr_info = {
              'number': workflow_run_pr_number,
              'title': test_results.get('pr_title', 'Unknown'),
              'author': test_results.get('pr_author', 'Unknown')
          }
          
          print(f"Starting auto upmerge for PR #{pr_info['number']} from {base_branch}")
          print(f"Target branches: {successful_merges}")
          
          # Hard coding project config (same as in upmerge-test)
          projectConfig = {
              "projectName": "HPCC4J",
              "projectPrefixes": ["HPCC4J"],
              "tagPrefix": "hpcc4j_",
              "tagPostfix": "-release"
          }
          
          # Track results
          upmerge_results = {
              "source_pr": pr_info,
              "source_branch": base_branch,
              "timestamp": time.strftime("%Y-%m-%d %H:%M:%S UTC", time.gmtime()),
              "attempted_branches": [],
              "successful_upmerges": [],
              "failed_upmerges": []
          }
          
          # Process each target branch
          for targetBranch in successful_merges:
              try:
                  targetVersion = getTargetInBranchVersion(targetBranch)
                  
                  upmerge_results["attempted_branches"].append({
                      "branch": targetBranch,
                      "version": targetVersion
                  })
                  
                  success = performUpmerge(base_branch, targetBranch, targetVersion, pr_info)
                  
                  if success:
                      upmerge_results["successful_upmerges"].append(targetBranch)
                      print(f"✅ Successfully upmerged to {targetBranch}")
                  else:
                      upmerge_results["failed_upmerges"].append(targetBranch)
                      print(f"❌ Failed to upmerge to {targetBranch}")
                      
              except Exception as e:
                  print(f"Error processing {targetBranch}: {e}")
                  upmerge_results["failed_upmerges"].append(targetBranch)
          
          # Save results
          with open('auto-upmerge-results.json', 'w') as f:
              json.dump(upmerge_results, f, indent=2)
          
          print(f"\nAuto upmerge completed:")
          print(f"Successful: {len(upmerge_results['successful_upmerges'])}")
          print(f"Failed: {len(upmerge_results['failed_upmerges'])}")
          
          if upmerge_results["failed_upmerges"]:
              print("Some upmerges failed. Check the logs for details.")
              sys.exit(1)

      - name: "Upload Auto Upmerge Results"
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: auto-upmerge-results-pr-${{ github.event.workflow_run.pull_requests[0].number }}
          path: |
            auto-upmerge-results.json
          retention-days: 30